# 1371. [Find the Longest Substring Containing Vowels in Even Counts][FLSCVEC] (每个元音包含偶数次的最长子字符串)

[FLSCVEC]: https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/

**Difficulty:** `medium`

**Tag:** `String`

------

## Question

Given the string `s`, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o' and 'u' must appear an even number of times.

------

## Solution

#### Approach 1 -- Prefix Sum + State Compression

Firstly, we consider about how to solve it by brute force. The most intuitive approach is enumerating all substrings, traversing all characters in these substrings and counting the number of vowels that appear. If conditions are met, we will update the answer. However, it will definitely fail all tests due to timeout in this way.

Let us look back the above operation. In fact,each substring corresponds to an interval. So, how could we quickly find the number of vowels in this interval without repeatedly traversing the substring? The answer is **prefix sum**. For an interval, we could use the difference between two prefix sums to get the number of a certain letter appearing times.

We maintain a prefix sum for each vowel, and define `pre[i][k]` to represent the number of times that `k`th vowel appears in the first `i` characters of the string. Assume we need to find whether the substring of the interval `[l,r]` satisfies the condition, we could use `pre[r][k] - pre[l][k]`. And we could get the number of times that `k`th vowel appears. For each vowel, we could determine whether it appears an even number of times.

We use prefix sums to optimize the time complexity of counting substrings. However, enumerating all substrings still requires O(N^2) which is not enough to pass this problem and we still need to optimize it to avoid enumerating all substrings. We consider about enumerating each `i` position of the string and calculate the longest substring that satisfies conditions ending at this position. In fact, what we need to do is finding the **smallest** `j ∈[0,i)` that satisfies `pre[i][k]-pre[j][k]` (that is, the number of times each vowel appears) is an even number. Then, the length of the longest string `s[j+1,i]` ending in `i` is `i-j`.

We could think of using hash table to optimize time complexity of lookup, however, we could not find the identities related to `i` and `j` by using the prefix sums alone. And we need to use another property in this problem: Each vowel appears exactly an **even number of times** in the substring we want.