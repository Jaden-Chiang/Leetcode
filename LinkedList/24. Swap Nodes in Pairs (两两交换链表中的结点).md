# 24. [Swap Nodes in Pairs][SNP] (两两交换链表中的结点)

[SNP]: https://leetcode-cn.com/problems/swap-nodes-in-pairs/

**Difficulty:** `medium`

**Tag:** `Linekd List` / `Recursion`

------

## Question

Given a linked list, swap every two adjacent nodes and return its head.

------

## Solution

#### Approach 1 -- Recursion

We could realize swapping nodes in pairs by using recursion. The termination condition is there are non nodes in the linked list or only one node. At this time, it could not be swapped.

If there are more than two nodes in the linekd list, the head node of original linked list will be the second node in the new linekd list after swapping. And the second node will be move to head. The remaining nodes in the linked list could swap recursively. After swapping, we need to update the pointer relationship between nodes.

Use `head` represents head node in the original linked list (it's also the second node in new linked list), use `newHead` represents head node in new linked list (it's also the second node in original linked list). The remaining nodes' head node is `newHead.next`. Use `head.next = swapPairs(newHead.next)` represents swap other nodes in pairs. The new head node is the next node of `head`, and then we make `newHead.next = head` to complete swapping. At last, we return the head node `newHead` of new linked list.

##### Reference Code

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return newHead;
    }
}
来源：力扣（LeetCode）
```

**Complexity:** `Time: O(N)` / `Space: O(N)`

##### Own Code

```java
class Solution {
    public ListNode swapPairs(ListNode head) {

        if (head == null) return null;
        if (head.next == null) return head;
        if (head.next.next == null) {
            ListNode curr = head.next;
            head.next = null;
            curr.next = head;
            return curr;
        }else {
            ListNode ans = deterChange(head);
            return ans;}}
        
        public ListNode deterChange(ListNode head){
            if (head == null) return null;
            ListNode p = head;
            if (head.next != null) {
                head = head.next;
            }else {
                return head;
            }
            ListNode q = head;
            if (head.next != null) {
                head = head.next;
            }else {
                p.next = null;
                q.next = p;
                return q;
            }
            q.next = p;
            p.next = deterChange(head);
            return q;
        }
}
```

*Record_1: In the recursion, the final return is the variable at the first recursion, so after entering the recursion, the initialization of thevariable would not effect the final result. For expamle, in the reference code, `newHead` will always be initialized. In the own code, the duplication of code (initialized `ans`) is due to unawareness of this problem.*